{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FOOSIEngine Documentation","text":"<p>Welcome \u2014 this is the docs hub for FOOSIEngine. Use the links below to jump to focused pages for each subsystem.</p> <ul> <li>Engine overview and lifecycle</li> <li>Object system &amp; prototypes</li> <li>Input listeners (mouse &amp; keyboard)</li> <li>Render pipeline</li> <li>Game-side helpers (engine_api)</li> <li>Build, run and debugging notes</li> <li>Project conventions &amp; patterns</li> </ul> <p>If you're new, start with the Engine overview then read the Object system page.</p>"},{"location":"ENGINE_FUNCTIONS/","title":"FOOSIEngine \u2014 Engine API Reference","text":"<p>This document summarizes the public/usable engine functions and common integration points. It's intended for engine users and script authors (game code in <code>game/</code>) and focuses on the functions that existing game code calls.</p>"},{"location":"ENGINE_FUNCTIONS/#key-components-high-level","title":"Key components (high level)","text":"<ul> <li><code>Engine</code> (class) \u2014 main runtime, manages window, GL context, input, objects and rendering. Defined in <code>engine/enginem.h</code> / <code>engine/enginem.cpp</code>.</li> <li><code>objManager</code> \u2014 object factory/registry and loader (reads <code>assets/objects.json</code>). Creates object instances and resolves textures.</li> <li><code>Object</code> \u2014 base class for game objects. Subclasses register via <code>ObjectFactory</code>.</li> <li><code>mListener</code> / <code>kListener</code> \u2014 input listeners for mouse &amp; keyboard with broadcast and high-level handlers (Down/Up/Hold).</li> <li><code>renderPipeline</code> \u2014 rendering subsystem (see <code>engine/render/*</code>).</li> </ul> <p>This reference documents the functions you should call from game code.</p>"},{"location":"ENGINE_FUNCTIONS/#engine-engineenginemh","title":"Engine (engine/enginem.h)","text":"<p>Public members and usage:</p> <ul> <li><code>Engine()</code> / <code>~Engine()</code></li> <li> <p>Constructor / destructor.</p> </li> <li> <p><code>void Init(const char* title, int w, int h, bool fullscreen)</code></p> </li> <li>Initialize SDL, GL context, create <code>objMgr</code>, <code>renderPipeline</code>, and input listeners.</li> <li>Example: <code>engine-&gt;Init(\"My Game\", 800, 600, false);</code></li> <li> <p>Side-effects: allocates <code>objMgr</code>, <code>rPipeline</code>, <code>mLnr</code>, <code>kLnr</code> if not present.</p> </li> <li> <p><code>void handleEvents()</code></p> </li> <li>Polls SDL events and forwards them to the input listeners. Also handles <code>SDL_QUIT</code>.</li> <li> <p>Call once per frame before <code>update()</code>.</p> </li> <li> <p><code>void update()</code></p> </li> <li>Calls every registry object's <code>Update()</code> and then ticks input listeners (this invokes Hold handlers). Also calls the global <code>Update()</code> hook from <code>game/main.cpp</code>.</li> <li> <p>Call each frame to progress game state.</p> </li> <li> <p><code>void render()</code></p> </li> <li> <p>Triggers the render pipeline (<code>rPipeline-&gt;renderAll()</code>).</p> </li> <li> <p><code>void clean()</code></p> </li> <li> <p>Tears down engine subsystems and SDL. Call on exit.</p> </li> <li> <p><code>bool running()</code></p> </li> <li> <p>Convenience inline that returns engine's running state.</p> </li> <li> <p><code>SDL_Window* getWindow()</code></p> </li> <li> <p>Returns the SDL window pointer for platform-specific integrations.</p> </li> <li> <p><code>void loadTileMap(const std::string&amp; jsonFile, int tileWidth, int tileHeight)</code></p> </li> <li>Loads a tilemap JSON and assigns it to <code>tileMap</code> (owned by Engine).</li> <li>Use <code>game/engine_api.h</code> wrapper <code>LoadTileMap()</code> for convenience.</li> </ul> <p>Public fields you may use (beware direct mutations): - <code>objManager* objMgr</code> \u2014 object manager; use its factory method to instantiate objects. - <code>mListener* mLnr</code> \u2014 mouse listener (register handlers or poll) - <code>kListener* kLnr</code> \u2014 keyboard listener - <code>renderPipeline* rPipeline</code> \u2014 rendering pipeline (low-level)</p> <p>Note: Prefer using the provided wrappers in <code>game/engine_api.h</code> (Instantiate, LoadTileMap) in scripts \u2014 they're thin convenience helpers and avoid repeating engine internals such as <code>engine-&gt;objMgr-&gt;instantiate(...)</code>.</p>"},{"location":"ENGINE_FUNCTIONS/#object-system","title":"Object system","text":"<p>Files: <code>engine/obj/*</code> and <code>game/assets/objects.json</code>.</p> <ul> <li><code>ObjectFactory::registerClass(name, creator)</code></li> <li>Register a class creator that returns a <code>unique_ptr&lt;Object&gt;</code>.</li> <li> <p>Example: <code>ObjectFactory::registerClass(\"tile\", [](){ return make_unique&lt;Tile_OBJ&gt;(); });</code></p> </li> <li> <p><code>objManager::obj_load(class, subclass)</code></p> </li> <li> <p>Creates a new <code>Object</code> instance for the class and subclass.</p> </li> <li> <p><code>objManager::instantiate(class, subclass, x, y, z)</code></p> </li> <li>Creates an instance, assigns position and id, applies prototype properties (see below), then calls <code>resolveTexture()</code>.</li> <li>Returns a raw pointer to the object owned by the manager's registry.</li> </ul>"},{"location":"ENGINE_FUNCTIONS/#prototype-properties-objectsjson","title":"Prototype properties (objects.json)","text":"<ul> <li><code>game/assets/objects.json</code> contains prototype entries with optional <code>properties</code> object.</li> <li>Prototypes may not override core engine-managed fields: <code>x</code>, <code>y</code>, <code>z</code>, <code>texref</code>. The engine will ignore these keys and emit a warning.</li> <li>To allow safe, flexible prototype-driven properties, <code>Object</code> now exposes a dynamic property registry:</li> <li>Derived classes call <code>registerFloatProperty(name, ref)</code>, <code>registerStringProperty(name, ref)</code>, or <code>registerProperty(name, setter)</code> in their constructor to expose named properties.</li> <li>When instantiating, the engine applies only registered property setters for keys found in the prototype's <code>properties</code> object.</li> </ul> <p>Example (Tile class):</p> <pre><code>// in Tile class constructor\nregisterFloatProperty(\"speed\", speed);\n</code></pre> <p>And in <code>objects.json</code>:</p> <pre><code>\"properties\": { \"speed\": 2.0 }\n</code></pre> <p>This will set the <code>speed</code> member on instantiated tiles.</p>"},{"location":"ENGINE_FUNCTIONS/#input-listeners-engineinput","title":"Input listeners (engine/input)","text":"<p><code>mListener</code> (mouse) and <code>kListener</code> (keyboard) provide two modes:</p> <ol> <li>Broadcast: <code>addHandler(fn)</code> receives every input event copy.</li> <li> <p>High-level registration: <code>onMouseDown(\"left\", fn)</code>, <code>onMouseHold(\"left\", fn)</code>, <code>onMouseUp(\"left\", fn)</code> and for keyboard <code>onKeyDown(\"a\", fn)</code>, <code>onKeyHold(...)</code>, <code>onKeyUp(...)</code>.</p> </li> <li> <p>Hold handlers are invoked from <code>Engine::update()</code> via <code>listener-&gt;tick()</code> and will be called every frame while the key/button is held.</p> </li> <li>For single-consumer/call-once semantics use the polling <code>get()</code> method which returns-and-clears the last event.</li> </ol> <p>Example:</p> <pre><code>engine-&gt;kLnr-&gt;onKeyHold(\"w\", [](const kListener::key &amp;k){ player-&gt;y += 1.0f; });\n</code></pre>"},{"location":"ENGINE_FUNCTIONS/#render-pipeline","title":"Render pipeline","text":"<p>See <code>engine/render/*</code>. The <code>renderPipeline</code> collects objects and textures into an atlas and renders them. Use <code>engine-&gt;rPipeline</code> sparingly \u2014 prefer higher-level helpers.</p>"},{"location":"ENGINE_FUNCTIONS/#game-side-helpers-gameengine_apih","title":"Game-side helpers (game/engine_api.h)","text":"<p>Includes small inline wrappers:</p> <p>-- <code>Object* Instantiate(const string &amp;class, const string &amp;subclass, float x, float y, float z)</code> \u2014 script-facing helper that instantiates a prototype; prefer this over calling engine internals. -- <code>void LoadTileMap(const string &amp;jsonFile, int tileWidth, int tileHeight)</code> \u2014 script-facing helper that loads a tilemap into the engine.</p> <p>Include <code>game/main.h</code> before <code>game/engine_api.h</code> to access the global <code>engine</code> pointer.</p>"},{"location":"ENGINE_FUNCTIONS/#debugging-build-notes","title":"Debugging &amp; build notes","text":"<ul> <li>Quick build/run: <code>cd game &amp;&amp; ./quickbnr.sh</code> (script cleans CMake caches, runs cmake/make and executes the game binary)</li> <li>If you change engine headers, cmake will reconfigure; if you get stale build artifacts, run <code>./quickbnr.sh</code> to clean and rebuild.</li> </ul>"},{"location":"ENGINE_FUNCTIONS/#conventions-patterns","title":"Conventions &amp; patterns","text":"<ul> <li>Object classes register themselves with <code>ObjectFactory</code> in their header files (see <code>engine/tile/tile_oclass.h</code>). This static-registration pattern runs at program startup.</li> <li>Prototype data lives in <code>game/assets/objects.json</code>. Keep only prototype-specific fields in <code>properties</code>; instance placement must be provided when calling <code>instantiate()</code>.</li> <li>Input: prefer high-level <code>onKey*/onMouse*</code> registration for game behavior. Use <code>addHandler</code> for global debug hooks.</li> </ul> <p>If you need example code or a change to the API surface (e.g., add unregister tokens, stronger validation, or per-scene prototype overrides) I can implement it next. </p>"},{"location":"build/","title":"Build, run and debugging notes","text":"<ul> <li>Quick runner: from <code>game/</code> run <code>./quickbnr.sh</code>. It cleans CMake state, runs <code>cmake ..</code>/<code>cmake .</code> then <code>make</code> and finally runs the built <code>game</code> binary.</li> <li>If you edit headers, cmake reconfigures; if builds behave oddly, run <code>./quickbnr.sh</code> to force a clean configure.</li> <li>Common dependencies: SDL2 (pkg-config name <code>sdl2</code>), jsoncpp, OpenGL, cmake, make, a C++ toolchain.</li> <li>If you get linker errors for missing symbols, ensure <code>engine/CMakeLists.txt</code> includes all engine source files (we added <code>input/keyboard.cpp</code> earlier).</li> </ul> <p>Runtime notes - The engine prints warnings when prototypes attempt to set core fields (<code>x,y,z,texref</code>). - Input handlers run on the main thread; avoid blocking operations in callbacks.</p>"},{"location":"conventions/","title":"Project conventions &amp; patterns","text":"<ul> <li>Object registration: classes register at static init time using <code>ObjectFactory::registerClass</code> (see <code>engine/tile/tile_oclass.h</code>).</li> <li>Prototype data: <code>game/assets/objects.json</code> contains subclasses and an optional <code>properties</code> block. Keep only prototype-level defaults there; instance placement belongs to <code>instantiate()</code>.</li> <li>Input: prefer <code>onKey*/onMouse*</code> high-level registration for game logic. Use <code>addHandler</code> for global tools.</li> <li>API wrappers: use <code>game/engine_api.h</code> for convenient script-level calls; these wrappers do not change engine internals.</li> </ul> <p>Style notes - Engine uses raw pointers for ownership where the engine owns resources (e.g., <code>objMgr-&gt;registry</code> holds unique_ptr"},{"location":"engine/","title":"Engine \u2014 overview and lifecycle","text":"<p>Location: <code>engine/enginem.h</code>, <code>engine/enginem.cpp</code></p> <p>What it is - <code>Engine</code> is the runtime owner for the window, GL context, input listeners, object manager, render pipeline and tilemap.</p> <p>Important functions - <code>Init(const char* title, int w, int h, bool fullscreen)</code> \u2014 Boot the engine, create subsystems, set GL attributes. - <code>handleEvents()</code> \u2014 Polls SDL events and forwards to input listeners. Handles <code>SDL_QUIT</code>. - <code>update()</code> \u2014 Calls each registry object's <code>Update()</code>, ticks input listeners (hold handlers), and calls the global <code>Update()</code> hook (game-provided). Should be called once per frame. - <code>render()</code> \u2014 Runs <code>rPipeline-&gt;renderAll()</code> to draw the frame. - <code>clean()</code> \u2014 Tears down subsystems and quits SDL.</p> <p>Fields you may use - <code>objManager* objMgr</code> \u2014 instantiate objects via <code>instantiate()</code> (prefer the wrapper <code>Instantiate()</code> in <code>game/engine_api.h</code>). - <code>mListener* mLnr</code>, <code>kListener* kLnr</code> \u2014 input listeners. - <code>renderPipeline* rPipeline</code> \u2014 low-level render access.</p> <p>Notes - Prefer the lightweight wrappers in <code>game/engine_api.h</code> for scripts (no engine changes required). - <code>Engine::update()</code> calls input <code>tick()</code>; handlers that want per-frame hold behavior should register with <code>onKeyHold</code>/<code>onMouseHold</code>.</p>"},{"location":"input/","title":"Input listeners \u2014 mouse &amp; keyboard","text":"<p>Location: <code>engine/input/mouse.h|cpp</code>, <code>engine/input/keyboard.h|cpp</code></p> <p>Modes - Broadcast: <code>addHandler(fn)</code> receives every event copy. - High-level: <code>onMouseDown(\"left\", fn)</code>, <code>onMouseHold(\"left\", fn)</code>, <code>onMouseUp(\"left\", fn)</code> and similarly for keys: <code>onKeyDown(\"a\", fn)</code>, etc.</p> <p>Hold semantics - Hold handlers are invoked from <code>Engine::update()</code> via <code>listener-&gt;tick()</code> and will be called each frame while the input is down. Use for continuous movement.</p> <p>Polling - <code>get()</code> returns-and-clears the last event (single-consumer semantics).</p> <p>Examples</p> <pre><code>// Run each frame while W is held\nengine-&gt;kLnr-&gt;onKeyHold(\"w\", [player](const kListener::key &amp;k){ player-&gt;y += 1.0f; });\n\n// Mouse left click\nengine-&gt;mLnr-&gt;onMouseDown(\"left\", [](const mListener::click&amp; c){ /* one-time */ });\n</code></pre> <p>Implementation notes - String names map to SDL constants (<code>\"left\"</code> -&gt; <code>SDL_BUTTON_LEFT</code>, <code>\"space\"</code> -&gt; <code>SDLK_SPACE</code>). - Callbacks run synchronously on the main thread (the SDL poll loop). Avoid long-running handlers.</p>"},{"location":"objects/","title":"Object system &amp; prototypes","text":"<p>Location: <code>engine/obj/*</code>, <code>game/assets/objects.json</code></p> <p>Key concepts - Classes vs Subclasses:   - A class maps to a C++ type (registered via <code>ObjectFactory::registerClass()</code>).   - A subclass is a JSON prototype: data-driven variant of a class (textures, properties).</p> <p>Factory &amp; Registry - <code>ObjectFactory::registerClass(name, creator)</code> registers class creators. - <code>objManager::instantiate(class, subclass, x,y,z)</code> creates an instance, assigns id/position, applies prototype properties (see below), and resolves textures. The instance is stored in <code>objManager::registry</code> and returned as a raw pointer (owned by the registry).</p> <p>Prototype <code>properties</code> - <code>game/assets/objects.json</code> may include a <code>properties</code> object per prototype. - Important: core engine-managed fields (<code>x</code>,<code>y</code>,<code>z</code>,<code>texref</code>) are ignored when set in prototypes. The engine will emit a warning and strip them. - To expose prototype-driven variables, classes must register named property setters:   - In a class constructor, call <code>registerFloatProperty(\"speed\", speed);</code> or <code>registerStringProperty(\"team\", teamName);</code>   - For custom parsing, use <code>registerProperty(\"loot\", [this](const Json::Value &amp;v){ /* parse */ });</code></p> <p>Example prototype:</p> <pre><code>{\n  \"obj_class\": \"tile\",\n  \"obj_subclass\": \"pPlayer\",\n  \"textures\": { \"default\": \"assets/player.png\" },\n  \"properties\": { \"speed\": 2.0 }\n}\n</code></pre> <p>Extending classes - Override <code>applyProperties</code> only if you need custom behavior; the preferred pattern is to register setters in the constructor.</p> <p>Why this design - Keeps engine-managed concerns separated from data-driven prototype properties. - Enables safe, explicit exposure of variables to JSON while preventing accidental overriding of instance placement or texture resolution.</p>"},{"location":"render/","title":"Render pipeline","text":"<p>Location: <code>engine/render/*</code></p> <p>Overview - The render pipeline collects textures and objects and builds a texture atlas for batched draws. - <code>renderPipeline::renderAll()</code> draws the current scene using the atlas and per-object transforms.</p> <p>Notes - The renderer is OpenGL 3.3 core-profile oriented (GLAD + SDL_GL context created in <code>Engine::Init</code>). - Textures are loaded via <code>Texture</code> helpers and combined into an atlas. If you add textures, ensure their lifetime is managed by the pipeline. - The rendering subsystem is lower-level; prefer high-level helpers in game code when available.</p>"}]}