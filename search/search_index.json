{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FOOSIEngine Documentation","text":"<p>Welcome \u2014 this is the docs hub for FOOSIEngine. Use the links below to jump to focused pages for each subsystem.</p> <ul> <li>Engine overview and lifecycle</li> <li>Beginner guide</li> <li>Object system &amp; prototypes</li> <li>Scene file format &amp; Scene manager</li> <li>Input listeners (mouse &amp; keyboard)</li> <li>Render pipeline</li> <li>Game-side helpers (engine_api)</li> <li>Build, run and debugging notes</li> <li>Project conventions &amp; patterns</li> </ul> <p>If you're new, start with the Engine overview then read the Object system page.</p>"},{"location":"ENGINE_FUNCTIONS/","title":"FOOSIEngine \u2014 Engine API Reference","text":"<p>This document summarizes the public/usable engine functions and common integration points. It's intended for engine users and script authors (game code in <code>game/</code>) and focuses on the functions that existing game code calls.</p>"},{"location":"ENGINE_FUNCTIONS/#key-components-high-level","title":"Key components (high level)","text":"<ul> <li><code>Engine</code> (class) \u2014 main runtime, manages window, GL context, input, objects and rendering. Defined in <code>engine/enginem.h</code> / <code>engine/enginem.cpp</code>.</li> <li><code>objManager</code> \u2014 object factory/registry and loader (reads <code>assets/objects.json</code>). Creates object instances and resolves textures.</li> <li><code>Object</code> \u2014 base class for game objects. Subclasses register via <code>ObjectFactory</code>.</li> <li><code>mListener</code> / <code>kListener</code> \u2014 input listeners for mouse &amp; keyboard with broadcast and high-level handlers (Down/Up/Hold).</li> <li><code>renderPipeline</code> \u2014 rendering subsystem (see <code>engine/render/*</code>).</li> </ul> <p>This reference documents the functions you should call from game code.</p>"},{"location":"ENGINE_FUNCTIONS/#engine-engineenginemh","title":"Engine (engine/enginem.h)","text":"<p>Public members and usage:</p> <ul> <li><code>Engine()</code> / <code>~Engine()</code></li> <li> <p>Constructor / destructor.</p> </li> <li> <p><code>void Init(const char* title, int w, int h, bool fullscreen)</code></p> </li> <li>Initialize SDL, GL context, create <code>objMgr</code>, <code>renderPipeline</code>, and input listeners.</li> <li>Example: <code>engine-&gt;Init(\"My Game\", 800, 600, false);</code></li> <li> <p>Side-effects: allocates <code>objMgr</code>, <code>rPipeline</code>, <code>mLnr</code>, <code>kLnr</code> if not present.</p> </li> <li> <p><code>void handleEvents()</code></p> </li> <li>Polls SDL events and forwards them to the input listeners. Also handles <code>SDL_QUIT</code>.</li> <li> <p>Call once per frame before <code>update()</code>.</p> </li> <li> <p><code>void update()</code></p> </li> <li>Calls every registry object's <code>Update()</code> and then ticks input listeners (this invokes Hold handlers). Also calls the global <code>Update()</code> hook from <code>game/main.cpp</code>.</li> <li> <p>Call each frame to progress game state.</p> </li> <li> <p><code>void render()</code></p> </li> <li> <p>Triggers the render pipeline (<code>rPipeline-&gt;renderAll()</code>).</p> </li> <li> <p><code>void clean()</code></p> </li> <li> <p>Tears down engine subsystems and SDL. Call on exit.</p> </li> <li> <p><code>bool running()</code></p> </li> <li> <p>Convenience inline that returns engine's running state.</p> </li> <li> <p><code>SDL_Window* getWindow()</code></p> </li> <li>Returns the SDL window pointer for platform-specific integrations.</li> </ul> <p>Public fields you may use (beware direct mutations): - <code>objManager* objMgr</code> \u2014 object manager; use its factory method to instantiate objects. - <code>mListener* mLnr</code> \u2014 mouse listener (register handlers or poll) - <code>kListener* kLnr</code> \u2014 keyboard listener - <code>renderPipeline* rPipeline</code> \u2014 rendering pipeline (low-level)</p> <p>Note: Prefer using the provided wrappers in <code>game/engine_api.h</code> (Instantiate, LoadTileMap) in scripts \u2014 they're thin convenience helpers and avoid repeating engine internals such as <code>engine-&gt;objMgr-&gt;instantiate(...)</code>.</p>"},{"location":"ENGINE_FUNCTIONS/#object-system","title":"Object system","text":"<p>Files: <code>engine/obj/*</code> and <code>game/assets/objects.json</code>.</p>"},{"location":"ENGINE_FUNCTIONS/#scene-manager-enginescene","title":"Scene manager (engine/scene)","text":"<ul> <li> <p><code>sceneManager::loadScene(path, baseX=0, baseY=0, baseZ=0)</code> \u2014 loads the named scene file from the configured scene folder (<code>sceneManager</code> is created by <code>Engine</code> and rooted at <code>game/demo/scn</code> by default). Nested <code>SCENE</code> references are loaded recursively and attached as children; object IDs belonging to the loaded scene are returned in a <code>sceneData</code> structure.</p> </li> <li> <p><code>sceneManager::unloadScene(path)</code> \u2014 removes all instantiated objects that were recorded when the scene was loaded (uses the internal <code>loadedScenes</code> map).</p> </li> <li> <p><code>sceneManager::saveScene(name)</code> \u2014 writes the scene to the scene folder using the textual format in <code>docs/scene.md</code>. Notes:</p> </li> <li>Creates the scene folder if missing.</li> <li>The header uses the scene name without a <code>.fscn</code> suffix.</li> <li>Nested <code>Scene_OBJ</code> children are written as <code>SCENE &lt;scene-file&gt;.fscn x y z;</code> and are not expanded into their children.</li> <li>Object coordinates are written relative to the saved scene root and rounded to integers.</li> </ul> <p>See <code>docs/scene.md</code> for syntax details and examples.</p> <ul> <li><code>ObjectFactory::registerClass(name, creator)</code></li> <li>Register a class creator that returns a <code>unique_ptr&lt;Object&gt;</code>.</li> <li> <p>Example: <code>ObjectFactory::registerClass(\"tile\", [](){ return make_unique&lt;Tile_OBJ&gt;(); });</code></p> </li> <li> <p><code>objManager::obj_load(class, subclass)</code></p> </li> <li> <p>Creates a new <code>Object</code> instance for the class and subclass.</p> </li> <li> <p><code>objManager::instantiate(class, subclass, x, y, z)</code></p> </li> <li>Creates an instance, assigns position and id, applies prototype properties (see below), then calls <code>resolveTexture()</code>.</li> <li>Returns a raw pointer to the object owned by the manager's registry.</li> </ul>"},{"location":"ENGINE_FUNCTIONS/#prototype-properties-objectsjson","title":"Prototype properties (objects.json)","text":"<ul> <li><code>game/assets/objects.json</code> contains prototype entries with optional <code>properties</code> object.</li> <li>Prototypes may not override core engine-managed fields: <code>x</code>, <code>y</code>, <code>z</code>, <code>texref</code>. The engine will ignore these keys and emit a warning.</li> <li>To allow safe, flexible prototype-driven properties, <code>Object</code> now exposes a dynamic property registry:</li> <li>Derived classes call <code>registerFloatProperty(name, ref)</code>, <code>registerStringProperty(name, ref)</code>, or <code>registerProperty(name, setter)</code> in their constructor to expose named properties.</li> <li>When instantiating, the engine applies only registered property setters for keys found in the prototype's <code>properties</code> object.</li> </ul> <p>Example (Tile class):</p> <pre><code>// in Tile class constructor\nregisterFloatProperty(\"speed\", speed);\n</code></pre> <p>And in <code>objects.json</code>:</p> <pre><code>\"properties\": { \"speed\": 2.0 }\n</code></pre> <p>This will set the <code>speed</code> member on instantiated tiles.</p>"},{"location":"ENGINE_FUNCTIONS/#input-listeners-engineinput","title":"Input listeners (engine/input)","text":"<p><code>mListener</code> (mouse) and <code>kListener</code> (keyboard) provide two modes:</p> <ol> <li>Broadcast: <code>addHandler(fn)</code> receives every input event copy.</li> <li> <p>High-level registration: <code>onMouseDown(\"left\", fn)</code>, <code>onMouseHold(\"left\", fn)</code>, <code>onMouseUp(\"left\", fn)</code> and for keyboard <code>onKeyDown(\"a\", fn)</code>, <code>onKeyHold(...)</code>, <code>onKeyUp(...)</code>.</p> </li> <li> <p>Hold handlers are invoked from <code>Engine::update()</code> via <code>listener-&gt;tick()</code> and will be called every frame while the key/button is held.</p> </li> <li>For single-consumer/call-once semantics use the polling <code>get()</code> method which returns-and-clears the last event.</li> </ol> <p>Example:</p> <pre><code>engine-&gt;kLnr-&gt;onKeyHold(\"w\", [](const kListener::key &amp;k){ player-&gt;y += 1.0f; });\n</code></pre>"},{"location":"ENGINE_FUNCTIONS/#render-pipeline","title":"Render pipeline","text":"<p>See <code>engine/render/*</code>. The <code>renderPipeline</code> collects objects and textures into an atlas and renders them. Use <code>engine-&gt;rPipeline</code> sparingly \u2014 prefer higher-level helpers.</p>"},{"location":"ENGINE_FUNCTIONS/#game-side-helpers-gameengine_apih","title":"Game-side helpers (game/engine_api.h)","text":"<p>Includes small inline wrappers:</p> <p>-- <code>Object* Instantiate(const string &amp;class, const string &amp;subclass, float x, float y, float z)</code> \u2014 script-facing helper that instantiates a prototype; prefer this over calling engine internals.</p> <p>Include <code>game/main.h</code> before <code>game/engine_api.h</code> to access the global <code>engine</code> pointer.</p>"},{"location":"ENGINE_FUNCTIONS/#debugging-build-notes","title":"Debugging &amp; build notes","text":"<ul> <li>Quick build/run: <code>cd game &amp;&amp; ./quickbnr.sh</code> (script cleans CMake caches, runs cmake/make and executes the game binary)</li> <li>If you change engine headers, cmake will reconfigure; if you get stale build artifacts, run <code>./quickbnr.sh</code> to clean and rebuild.</li> </ul>"},{"location":"ENGINE_FUNCTIONS/#conventions-patterns","title":"Conventions &amp; patterns","text":"<ul> <li>Object classes register themselves with <code>ObjectFactory</code> in their header files (see <code>engine/tile/tile_oclass.h</code>). This static-registration pattern runs at program startup.</li> <li>Prototype data lives in <code>game/assets/objects.json</code>. Keep only prototype-specific fields in <code>properties</code>; instance placement must be provided when calling <code>instantiate()</code>.</li> <li>Input: prefer high-level <code>onKey*/onMouse*</code> registration for game behavior. Use <code>addHandler</code> for global debug hooks.</li> </ul> <p>If you need example code or a change to the API surface (e.g., add unregister tokens, stronger validation, or per-scene prototype overrides) I can implement it next. </p>"},{"location":"beginner/","title":"Beginner Guide","text":"<p>This quick-start guide helps you get a small FOOSIEngine project running and shows common tasks for new contributors.</p>"},{"location":"beginner/#prerequisites","title":"Prerequisites","text":"<ul> <li>Ideally a linux-based operating system. Build tools: <code>cmake</code>, <code>make</code> or Ninja, <code>g++</code>.</li> <li>SDL2 and jsoncpp installed (your distro package manager provides these).</li> </ul>"},{"location":"beginner/#build-run","title":"Build &amp; Run","text":"<ol> <li>From the repository root run:</li> </ol> <p>./quickbnr.sh --ninja</p> <p>This configures, builds and runs the demo binary. Use <code>--gmake</code> to prefer GNU Make.</p> <ol> <li>The demo loads <code>game/demo/scn/test.fscn</code> on startup which demonstrates scene loading and nested children.</li> </ol>"},{"location":"beginner/#editing-scenes","title":"Editing scenes","text":"<ul> <li>Scene files live under <code>game/demo/scn/</code>.</li> <li>Syntax basics (see <code>docs/scene.md</code> for full reference):</li> <li><code>#SCNDEF &lt;name&gt;</code> header and <code>#ENDSCN</code> footer</li> <li><code>OBJECT tile.grass 10 10 0;</code> \u2014 instantiate an object at coordinates (x,y,z)</li> <li> <p>Child blocks (inline nesting):</p> <p>OBJECT tile.parent 10 10 0 {     OBJECT tile.child 1 1 1; };</p> </li> <li> <p><code>SCENE &lt;file.fscn&gt; x y z;</code> \u2014 reference another scene (child scenes are attached as references when loading).</p> </li> <li> <p>Important: scene files must use object prototypes defined in <code>game/demo/objects.json</code>. If you reference an unknown subclass <code>Instantiate()</code> will return <code>nullptr</code> and the loader will skip the entry.</p> </li> </ul>"},{"location":"beginner/#working-with-objects-sample-code","title":"Working with objects (sample code)","text":"<p>Here's a short example that demonstrates common operations you can try in <code>game/main.cpp</code> or a small test program:</p> <pre><code>// instantiate a tile at (10,10,0)\nObject* t = Instantiate(\"tile\", \"grass\", 10, 10, 0);\n\n// create a parent object and attach a child\nObject* parent = Instantiate(\"tile\", \"pTest\", 5, 5, 0);\nObject* child = Instantiate(\"tile\", \"grass\", 1, 1, 1);\nengine-&gt;objMgr-&gt;addChild(parent, child);\n\n// print current object tree to stdout\nengine-&gt;objMgr-&gt;printTree(engine-&gt;objMgr-&gt;getRoot());\n\n// save the current scene (writes to demo/scn/&lt;name&gt;.fscn)\nengine-&gt;sceneMgr-&gt;saveScene(\"test\");\n</code></pre> <ul> <li>Notes:</li> <li>Use <code>Instantiate()</code> (from <code>game/engine_api.h</code>) rather than constructing objects directly.</li> <li>The object manager owns all instantiated objects; you should not delete them manually.</li> </ul>"},{"location":"beginner/#try-it-quick-exercise","title":"Try it (quick exercise)","text":"<ol> <li>Open <code>game/main.cpp</code> and add the sample code above after <code>engine-&gt;Init(...)</code> to create objects at runtime.</li> <li>Build with <code>./quickbnr.sh -n</code> and run; inspect the logged object tree and the generated <code>game/demo/scn/test.fscn</code> file.</li> <li>Edit the saved <code>.fscn</code> file and reload to verify the loader handles nested child syntax.</li> </ol>"},{"location":"beginner/#where-to-look-next","title":"Where to look next","text":"<ul> <li><code>docs/scene.md</code> \u2014 full syntax and save/load semantics</li> <li><code>docs/objects.md</code> \u2014 how prototypes and properties work</li> <li><code>engine/obj/*</code> \u2014 object implementation &amp; factory pattern</li> </ul> <p>If you'd like, I can add a short example project page showing how to create a minimal scene programmatically and save it to disk.</p>"},{"location":"build/","title":"Build, run and debugging notes","text":"<ul> <li>Quick runner: from <code>game/</code> run <code>./quickbnr.sh</code>. It cleans CMake state, runs <code>cmake ..</code>/<code>cmake .</code> then <code>make</code> and finally runs the built <code>game</code> binary.</li> <li>If you edit headers, cmake reconfigures; if builds behave oddly, run <code>./quickbnr.sh</code> to force a clean configure.</li> <li>Common dependencies: SDL2 (pkg-config name <code>sdl2</code>), jsoncpp, OpenGL, cmake, make, a C++ toolchain.</li> <li>If you get linker errors for missing symbols, ensure <code>engine/CMakeLists.txt</code> includes all engine source files (we added <code>input/keyboard.cpp</code> earlier).</li> </ul> <p>Runtime notes - The engine prints warnings when prototypes attempt to set core fields (<code>x,y,z,texref</code>). - Input handlers run on the main thread; avoid blocking operations in callbacks.</p>"},{"location":"conventions/","title":"Project conventions &amp; patterns","text":"<ul> <li>Object registration: classes register at static init time using <code>ObjectFactory::registerClass</code> (see <code>engine/tile/tile_oclass.h</code>).</li> <li>Prototype data: <code>game/assets/objects.json</code> contains subclasses and an optional <code>properties</code> block. Keep only prototype-level defaults there; instance placement belongs to <code>instantiate()</code>.</li> <li>Input: prefer <code>onKey*/onMouse*</code> high-level registration for game logic. Use <code>addHandler</code> for global tools.</li> <li>API wrappers: use <code>game/engine_api.h</code> for convenient script-level calls; these wrappers do not change engine internals.</li> </ul> <p>Style notes - Engine uses raw pointers for ownership where the engine owns resources (e.g., <code>objMgr-&gt;registry</code> holds unique_ptr"},{"location":"engine/","title":"Engine \u2014 overview and lifecycle","text":"<p>Location: <code>engine/enginem.h</code>, <code>engine/enginem.cpp</code></p> <p>What it is - <code>Engine</code> is the runtime owner for the window, GL context, input listeners, object manager, and render pipeline.</p> <p>Important functions - <code>Init(const char* title, int w, int h, bool fullscreen)</code> \u2014 Boot the engine, create subsystems, set GL attributes. - <code>handleEvents()</code> \u2014 Polls SDL events and forwards to input listeners. Handles <code>SDL_QUIT</code>. - <code>update()</code> \u2014 Calls each registry object's <code>Update()</code>, ticks input listeners (hold handlers), and calls the global <code>Update()</code> hook (game-provided). Should be called once per frame. - <code>render()</code> \u2014 Runs <code>rPipeline-&gt;renderAll()</code> to draw the frame. - <code>clean()</code> \u2014 Tears down subsystems and quits SDL.</p> <p>Fields you may use - <code>objManager* objMgr</code> \u2014 instantiate objects via <code>instantiate()</code> (prefer the wrapper <code>Instantiate()</code> in <code>game/engine_api.h</code>). - <code>mListener* mLnr</code>, <code>kListener* kLnr</code> \u2014 input listeners. - <code>renderPipeline* rPipeline</code> \u2014 low-level render access.</p> <p>Notes - Prefer the lightweight wrappers in <code>game/engine_api.h</code> for scripts (no engine changes required). - <code>Engine::update()</code> calls input <code>tick()</code>; handlers that want per-frame hold behavior should register with <code>onKeyHold</code>/<code>onMouseHold</code>.</p>"},{"location":"input/","title":"Input listeners \u2014 mouse &amp; keyboard","text":"<p>Location: <code>engine/input/mouse.h|cpp</code>, <code>engine/input/keyboard.h|cpp</code></p> <p>Modes - Broadcast: <code>addHandler(fn)</code> receives every event copy. - High-level: <code>onMouseDown(\"left\", fn)</code>, <code>onMouseHold(\"left\", fn)</code>, <code>onMouseUp(\"left\", fn)</code> and similarly for keys: <code>onKeyDown(\"a\", fn)</code>, etc.</p> <p>Hold semantics - Hold handlers are invoked from <code>Engine::update()</code> via <code>listener-&gt;tick()</code> and will be called each frame while the input is down. Use for continuous movement.</p> <p>Polling - <code>get()</code> returns-and-clears the last event (single-consumer semantics).</p> <p>Examples</p> <pre><code>// Run each frame while W is held\nengine-&gt;kLnr-&gt;onKeyHold(\"w\", [player](const kListener::key &amp;k){ player-&gt;y += 1.0f; });\n\n// Mouse left click\nengine-&gt;mLnr-&gt;onMouseDown(\"left\", [](const mListener::click&amp; c){ /* one-time */ });\n</code></pre> <p>Implementation notes - String names map to SDL constants (<code>\"left\"</code> -&gt; <code>SDL_BUTTON_LEFT</code>, <code>\"space\"</code> -&gt; <code>SDLK_SPACE</code>). - Callbacks run synchronously on the main thread (the SDL poll loop). Avoid long-running handlers.</p>"},{"location":"objects/","title":"Object system &amp; prototypes","text":"<p>Location: <code>engine/obj/*</code>, <code>game/assets/objects.json</code></p>"},{"location":"objects/#key-concepts","title":"Key concepts","text":""},{"location":"objects/#-classes-vs-subclasses","title":"- Classes vs Subclasses:","text":"<ul> <li>A class maps to a C++ type (registered via <code>ObjectFactory::registerClass()</code>).</li> <li>A subclass is a JSON prototype: data-driven variant of a class (textures, properties).</li> </ul>"},{"location":"objects/#factory-registry","title":"Factory &amp; Registry","text":"<ul> <li><code>ObjectFactory::registerClass(name, creator)</code> registers class creators.</li> <li><code>objManager::instantiate(class, subclass, x,y,z)</code> creates an instance, assigns id/position, applies prototype properties (see below), and resolves textures. The instance is stored in <code>objManager::registry</code> and returned as a raw pointer (owned by the registry).</li> </ul>"},{"location":"objects/#prototype-properties","title":"Prototype <code>properties</code>","text":"<ul> <li><code>game/assets/objects.json</code> may include a <code>properties</code> object per prototype.</li> <li>Important: core engine-managed fields (<code>x</code>,<code>y</code>,<code>z</code>,<code>texref</code>) are ignored when set in prototypes. The engine will emit a warning and strip them.</li> </ul>"},{"location":"objects/#engine-validation","title":"Engine validation","text":"<ul> <li>The engine requires that any <code>OBJECT</code> referenced in scene files corresponds to a prototype present in <code>game/assets/objects.json</code> (i.e. valid <code>obj_class</code> and <code>obj_subclass</code>). If a prototype is missing, <code>Instantiate()</code> will return <code>nullptr</code> and the loader will skip the entry. Ensure your scene files only reference defined subclasses (for example: <code>tile.grass</code>, <code>tile.half_grass</code>, <code>tile.pTest</code>).</li> <li>To expose prototype-driven variables, classes must register named property setters:</li> <li>In a class constructor, call <code>registerFloatProperty(\"speed\", speed);</code> or <code>registerStringProperty(\"team\", teamName);</code></li> <li>For custom parsing, use <code>registerProperty(\"loot\", [this](const Json::Value &amp;v){ /* parse */ });</code></li> </ul>"},{"location":"objects/#example-prototype","title":"Example prototype:","text":"<pre><code>{\n  \"obj_class\": \"tile\",\n  \"obj_subclass\": \"pPlayer\",\n  \"textures\": { \"default\": \"assets/player.png\" },\n  \"properties\": { \"speed\": 2.0 }\n}\n</code></pre>"},{"location":"objects/#extending-classes","title":"Extending classes","text":"<ul> <li>Override <code>applyProperties</code> only if you need custom behavior; the preferred pattern is to register setters in the constructor.</li> </ul>"},{"location":"objects/#object-manipulation","title":"Object Manipulation","text":""},{"location":"objects/#creation","title":"Creation","text":"<p>-- <code>Object* Instantiate(const string &amp;class, const string &amp;subclass, float x, float y, float z)</code>     - Script-friendly wrapper for instantiating prototypes. Prefer calling this helper from game code instead of accessing engine internals.     - Returns a raw pointer owned by the engine registry.</p>"},{"location":"objects/#hierarchy-manipulation","title":"Hierarchy Manipulation","text":"<p>-- <code>void objManager::addChild(Object* parent, Object* child)</code>    - Makes <code>child</code> a child of <code>parent</code> and removes libks between <code>child</code> and previous parents.   -- <code>void objManager::removeChild(Object* parent, Object* child)</code>      - Makes <code>child</code> no longer a child of <code>parent</code>.      - <code>child</code> becomes a child of the <code>ROOT</code> object.   -- <code>Object* Object::getParent()</code>    - Gets the parent of the <code>Object</code> chosen. </p>"},{"location":"objects/#registry","title":"Registry","text":"<p>-- <code>void objManager::printTree(Object* obj, const std::string&amp; prefix = \"\", bool isLast = true)</code>    -  Prints out entire hierarchy from <code>obj</code>.   -- <code>void objManager::printRegistry() const</code>    - Prints out entire registry, ignoring hierarchy.   -- <code>Object* objManager::getRoot() const</code>    - Returns the <code>ROOT</code> object, parent of all other objects. </p>"},{"location":"objects/#why-this-design","title":"Why this design","text":"<ul> <li>Keeps engine-managed concerns separated from data-driven prototype properties.</li> <li>Enables safe, explicit exposure of variables to JSON while preventing accidental overriding of instance placement or texture resolution.</li> </ul>"},{"location":"render/","title":"Render pipeline","text":"<p>Location: <code>engine/render/*</code></p> <p>Overview - The render pipeline collects textures and objects and builds a texture atlas for batched draws. - <code>renderPipeline::renderAll()</code> draws the current scene using the atlas and per-object transforms.</p> <p>Notes - The renderer is OpenGL 3.3 core-profile oriented (GLAD + SDL_GL context created in <code>Engine::Init</code>). - Textures are loaded via <code>Texture</code> helpers and combined into an atlas. If you add textures, ensure their lifetime is managed by the pipeline. - The rendering subsystem is lower-level; prefer high-level helpers in game code when available.</p>"},{"location":"scene/","title":"Scene file format &amp; Scene manager","text":"<p>Location: <code>engine/scene/*</code> and <code>game/demo/scn/*</code></p> <p>This page documents the textual scene format and the <code>sceneManager</code> API used to load and save scenes.</p>"},{"location":"scene/#file-layout","title":"File layout","text":"<p>A scene file uses a simple line-oriented format with a header and footer:</p> <ul> <li>Header: <code>#SCNDEF &lt;scene-name&gt;</code> where <code>&lt;scene-name&gt;</code> is a short identifier (no <code>.fscn</code> suffix required in the header)</li> <li>Body: one or more <code>OBJECT</code> and <code>SCENE</code> statements and optional nested blocks</li> <li>Footer: <code>#ENDSCN</code></li> </ul> <p>Example (short):</p> <pre><code>#SCNDEF test\n{\n    OBJECT tile.grass 10 10 0;\n    OBJECT tile.pTest 10 10 1\n    {\n        OBJECT tile.grass 0 0 1;\n    };\n    SCENE test2.fscn 11 11 0;\n};\n#ENDSCN\n</code></pre>"},{"location":"scene/#syntax-rules","title":"Syntax rules","text":"<ul> <li>Lines are trimmed and empty lines ignored.</li> <li>Commands use an initial keyword and arguments separated by whitespace.</li> <li>Commands include:</li> <li><code>OBJECT &lt;class&gt;[.&lt;subclass&gt;] &lt;x&gt; &lt;y&gt; &lt;z&gt;</code> \u2014 instantiate an object at the integer coordinates.<ul> <li>If the line ends with <code>;</code> it is a leaf object. If the line is followed by a <code>{</code> block, the following objects become children of this object (see Child blocks below).</li> </ul> </li> <li><code>SCENE &lt;path&gt; &lt;x&gt; &lt;y&gt; &lt;z&gt;</code> \u2014 create a reference to another scene file. The <code>path</code> should be a valid scene filename (e.g., <code>test2.fscn</code>). When loading, <code>SCENE</code> will load the referenced scene and attach its scene object as a child.</li> </ul>"},{"location":"scene/#child-blocks","title":"Child blocks","text":"<ul> <li>You can nest objects by placing a <code>{</code> on its own line after an <code>OBJECT</code> line, then placing child <code>OBJECT</code> or <code>SCENE</code> lines inside the block, and terminate the block with <code>};</code> (the close brace optionally followed by <code>;</code>).</li> <li>If an <code>OBJECT</code> is not followed by a <code>{</code> it is treated as a leaf and must end with <code>;</code>.</li> <li>Example multi-level nesting:</li> </ul> <pre><code>OBJECT tile.parent 10 10 0\n{\n    OBJECT tile.child 1 1 1;\n    OBJECT tile.withgrand 2 2 1\n    {\n        OBJECT tile.grandchild 0 1 0;\n    };\n};\n</code></pre> <ul> <li>If a closing brace includes a trailing <code>;</code> (i.e., <code>};</code>) it not only closes the block, but terminates the most recent object so subsequent sibling blocks are not nested under it.</li> </ul>"},{"location":"scene/#loading-behavior","title":"Loading behavior","text":"<ul> <li><code>sceneManager::loadScene(path, baseX, baseY, baseZ)</code> reads the specified file from the configured scene folder and instantiates objects.</li> <li>The loader maintains a stack of parent objects to support nested <code>{}</code> blocks; if no previous object exists for a <code>{</code> it treats the scene root as the parent for that block.</li> <li>Nested <code>SCENE</code> references are loaded recursively; the nested scene's root object is attached to the parent, and all object IDs from the nested load are aggregated into the calling scene's <code>sceneData</code>.</li> <li>All instantiated coordinates are the sum of the explicit coordinates and the <code>baseX</code>, <code>baseY</code>, <code>baseZ</code> offsets passed to <code>loadScene</code>.</li> </ul>"},{"location":"scene/#saving-behavior","title":"Saving behavior","text":"<ul> <li><code>sceneManager::saveScene(name)</code> serializes a scene back to a <code>.fscn</code> file in the scene folder.</li> <li>Behavior details:</li> <li>If the scene folder does not exist it is created automatically.</li> <li>The header <code>#SCNDEF &lt;name&gt;</code> uses the scene's name without a <code>.fscn</code> suffix.</li> <li>Coordinates are written as integers relative to the saved scene's root object.</li> <li>Nested <code>Scene_OBJ</code> instances (child scenes) are written as <code>SCENE &lt;scene-name&gt;.fscn &lt;x&gt; &lt;y&gt; &lt;z&gt;;</code> and their children are intentionally not expanded in the file (a child scene is saved as a reference only).</li> <li>Objects are saved using the inline <code>{ ... };</code> child-block syntax for children.</li> </ul>"},{"location":"scene/#notes-constraints","title":"Notes &amp; constraints","text":"<ul> <li>The engine expects object prototypes (class+subclass) to be defined in <code>game/assets/objects.json</code>. <code>Instantiate()</code> will fail if a prototype is missing.</li> <li>The parser is forgiving about spacing but requires <code>;</code> terminators (or an inline <code>{</code> block) to disambiguate object termination.</li> </ul>"},{"location":"scene/#example-files","title":"Example files","text":"<ul> <li>See <code>game/demo/scn/test.fscn</code> and <code>game/demo/scn/test_child.fscn</code> for working examples of nested child syntax and <code>SCENE</code> references.</li> </ul> <p>If you want <code>saveScene</code> to also persist per-object properties (textures, custom properties), I can extend the file format to include a mini-property block for objects; tell me your preferred syntax and I'll implement it.</p>"}]}